{"version":3,"file":"static/js/9996.6bad4ac5.chunk.js","mappings":"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","sources":["../../../streamlit/frontend/lib/src/components/widgets/Form/FormClearHelper.ts","../../../streamlit/frontend/lib/src/components/widgets/Selectbox/Selectbox.tsx","../../../streamlit/frontend/lib/src/useBasicWidgetState.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { useEffect } from \"react\"\n\nimport { SignalConnection } from \"typed-signals\"\n\nimport {\n  isValidFormId,\n  notNullOrUndefined,\n} from \"@streamlit/lib/src/util/utils\"\nimport { WidgetStateManager } from \"@streamlit/lib/src/WidgetStateManager\"\n\nexport class FormClearHelper {\n  private formClearListener?: SignalConnection\n\n  private lastWidgetMgr?: WidgetStateManager\n\n  private lastFormId?: string\n\n  /**\n   * Register the listener that will be called when the widget's form is cleared.\n   * This should be called in the `render` function of every class-based widget\n   * element - it mimics the behavior of a `useEffect` hook, and ensures that\n   * subscription and unsubscription happen correctly.\n   *\n   * Hooks-based widgets can just use `useEffect` and call\n   * `widgetMgr.addFormClearedListener` directly. Or just use the convenient\n   * hook `useFormClearHelper`, below.\n   */\n  public manageFormClearListener(\n    widgetMgr: WidgetStateManager,\n    formId: string,\n    listener: () => void\n  ): void {\n    // If we're already subscribed and our params haven't changed, early-out.\n    if (\n      notNullOrUndefined(this.formClearListener) &&\n      this.lastWidgetMgr === widgetMgr &&\n      this.lastFormId === formId\n    ) {\n      return\n    }\n\n    // Close our previous subscription, if we had one.\n    this.disconnect()\n\n    // If we're not part of a form, there's nothing to do.\n    if (!isValidFormId(formId)) {\n      return\n    }\n\n    // Make the new subscription.\n    this.formClearListener = widgetMgr.addFormClearedListener(formId, listener)\n    this.lastWidgetMgr = widgetMgr\n    this.lastFormId = formId\n  }\n\n  /**\n   * Disconnect from the form-clear signal, if we're connected.\n   * This should be called from the `componentWillUnmount` function of every\n   * element that uses it.\n   */\n  public disconnect(): void {\n    this.formClearListener?.disconnect()\n    this.formClearListener = undefined\n    this.lastWidgetMgr = undefined\n    this.lastFormId = undefined\n  }\n}\n\ninterface FormElementProtoInterface {\n  formId: string\n}\n\ninterface FormClearHelperArgs {\n  element: FormElementProtoInterface\n  widgetMgr: WidgetStateManager\n  onFormCleared: () => void\n}\n\nexport function useFormClearHelper({\n  element,\n  widgetMgr,\n  onFormCleared,\n}: FormClearHelperArgs): void {\n  useEffect(() => {\n    if (!isValidFormId(element.formId)) {\n      return\n    }\n\n    const formClearListener = widgetMgr.addFormClearedListener(\n      element.formId,\n      onFormCleared\n    )\n\n    return () => {\n      formClearListener.disconnect()\n    }\n  }, [element, widgetMgr, onFormCleared])\n}\n","/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { FC, memo, useCallback } from \"react\"\n\nimport { Selectbox as SelectboxProto } from \"@streamlit/lib/src/proto\"\nimport { WidgetStateManager } from \"@streamlit/lib/src/WidgetStateManager\"\nimport UISelectbox from \"@streamlit/lib/src/components/shared/Dropdown\"\nimport {\n  isNullOrUndefined,\n  labelVisibilityProtoValueToEnum,\n} from \"@streamlit/lib/src/util/utils\"\nimport {\n  useBasicWidgetState,\n  ValueWithSource,\n} from \"@streamlit/lib/src/useBasicWidgetState\"\n\nexport interface Props {\n  disabled: boolean\n  element: SelectboxProto\n  widgetMgr: WidgetStateManager\n  width: number\n  fragmentId?: string\n}\n\n/**\n * The value specified by the user via the UI. If the user didn't touch this\n * widget's UI, the default value is used.\n */\ntype SelectboxValue = number | null\n\nconst getStateFromWidgetMgr = (\n  widgetMgr: WidgetStateManager,\n  element: SelectboxProto\n): SelectboxValue | undefined => {\n  return widgetMgr.getIntValue(element)\n}\n\nconst getDefaultStateFromProto = (element: SelectboxProto): SelectboxValue => {\n  return element.default ?? null\n}\n\nconst getCurrStateFromProto = (element: SelectboxProto): SelectboxValue => {\n  return element.value ?? null\n}\n\nconst updateWidgetMgrState = (\n  element: SelectboxProto,\n  widgetMgr: WidgetStateManager,\n  valueWithSource: ValueWithSource<SelectboxValue>,\n  fragmentId?: string\n): void => {\n  widgetMgr.setIntValue(\n    element,\n    valueWithSource.value,\n    { fromUi: valueWithSource.fromUi },\n    fragmentId\n  )\n}\n\nconst Selectbox: FC<Props> = ({\n  disabled,\n  element,\n  widgetMgr,\n  width,\n  fragmentId,\n}) => {\n  const { options, help, label, labelVisibility, placeholder } = element\n\n  const [value, setValueWithSource] = useBasicWidgetState<\n    SelectboxValue,\n    SelectboxProto\n  >({\n    getStateFromWidgetMgr,\n    getDefaultStateFromProto,\n    getCurrStateFromProto,\n    updateWidgetMgrState,\n    element,\n    widgetMgr,\n    fragmentId,\n  })\n\n  const onChange = useCallback(\n    (value: SelectboxValue) => {\n      setValueWithSource({ value, fromUi: true })\n    },\n    [setValueWithSource]\n  )\n\n  const clearable = isNullOrUndefined(element.default) && !disabled\n\n  return (\n    <UISelectbox\n      label={label}\n      labelVisibility={labelVisibilityProtoValueToEnum(labelVisibility?.value)}\n      options={options}\n      disabled={disabled}\n      width={width}\n      onChange={onChange}\n      value={value}\n      help={help}\n      placeholder={placeholder}\n      clearable={clearable}\n    />\n  )\n}\n\nexport default memo(Selectbox)\n","/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Dispatch,\n  SetStateAction,\n  useCallback,\n  useEffect,\n  useState,\n} from \"react\"\n\nimport {\n  Source,\n  WidgetStateManager,\n} from \"@streamlit/lib/src/WidgetStateManager\"\nimport { useFormClearHelper } from \"@streamlit/lib/src/components/widgets/Form\"\nimport { isNullOrUndefined } from \"@streamlit/lib/src/util/utils\"\n\nexport type ValueWithSource<T> = {\n  value: T\n} & Source\n\n// Interface for a proto that has a .formId\ninterface ValueElementProtoInterface {\n  formId: string\n}\n\ninterface BaseArgs<\n  T, // Type of the value stored in WidgetStateManager.\n  P extends ValueElementProtoInterface // Proto for this widget.\n> {\n  // Important: these callback functions need to have stable references! So\n  // either declare them at the module level or wrap in useCallback.\n  getStateFromWidgetMgr: (wm: WidgetStateManager, el: P) => T | undefined\n  updateWidgetMgrState: (\n    el: P,\n    wm: WidgetStateManager,\n    vws: ValueWithSource<T>,\n    fragmentId?: string\n  ) => void\n  element: P\n  widgetMgr: WidgetStateManager\n  fragmentId?: string\n  onFormCleared?: () => void\n}\n\nexport interface UseBasicWidgetClientStateArgs<\n  T, // Type of the value stored in WidgetStateManager.\n  P extends ValueElementProtoInterface // Proto for this widget.\n> extends BaseArgs<T, P> {\n  // Important: these callback functions need to have stable references! So\n  // either declare them at the module level or wrap in useCallback.\n  getDefaultState: (wm: WidgetStateManager, el: P) => T\n}\n\n/**\n * A React hook that makes the simplest kinds of widgets very easy to implement.\n * Use the clientState version when the widget does not have a .setValue on its\n * proto, otherwise utilize `useBasicWidgetState`.\n */\nexport function useBasicWidgetClientState<\n  T, // Type of the value stored in WidgetStateManager.\n  P extends ValueElementProtoInterface // Proto for this widget.\n>({\n  getStateFromWidgetMgr,\n  getDefaultState,\n  updateWidgetMgrState,\n  element,\n  widgetMgr,\n  fragmentId,\n  onFormCleared,\n}: UseBasicWidgetClientStateArgs<T, P>): [\n  T,\n  Dispatch<SetStateAction<ValueWithSource<T> | null>>\n] {\n  const [currentValue, setCurrentValue] = useState<T>(() => {\n    // If WidgetStateManager knew a value for this widget, initialize to that.\n    // Otherwise, use the default value.\n    return (\n      getStateFromWidgetMgr(widgetMgr, element) ??\n      getDefaultState(widgetMgr, element)\n    )\n  })\n\n  // This acts as an \"event\":\n  // - It's null most of the time\n  // - It only has a value the moment when the user calls setValue (internally\n  //   called setNextValueWithSource). And then it's immediately set to null\n  //   internally.\n  const [nextValueWithSource, setNextValueWithSource] =\n    useState<ValueWithSource<T> | null>({\n      value: currentValue,\n      fromUi: false,\n    })\n\n  // When someone calls setNextValueWithSource, update internal state and tell\n  // widget manager to update its state too.\n  useEffect(() => {\n    if (isNullOrUndefined(nextValueWithSource)) return\n    setNextValueWithSource(null) // Clear \"event\".\n\n    setCurrentValue(nextValueWithSource.value)\n    updateWidgetMgrState(element, widgetMgr, nextValueWithSource, fragmentId)\n  }, [\n    nextValueWithSource,\n    updateWidgetMgrState,\n    element,\n    widgetMgr,\n    fragmentId,\n  ])\n\n  /**\n   * If we're part of a clear_on_submit form, this will be called when our\n   * form is submitted. Restore our default value and update the WidgetManager.\n   */\n  const handleFormCleared = useCallback((): void => {\n    setNextValueWithSource({\n      value: getDefaultState(widgetMgr, element),\n      fromUi: true,\n    })\n    onFormCleared?.()\n  }, [\n    setNextValueWithSource,\n    element,\n    getDefaultState,\n    widgetMgr,\n    onFormCleared,\n  ])\n\n  // Manage our form-clear event handler.\n  useFormClearHelper({ widgetMgr, element, onFormCleared: handleFormCleared })\n\n  return [currentValue, setNextValueWithSource]\n}\n\n// Interface for a proto that has a setValue, and .formId\ninterface ValueElementProtoInterfaceWithSetValue\n  extends ValueElementProtoInterface {\n  setValue: boolean\n}\n\nexport interface UseBasicWidgetStateArgs<\n  T, // Type of the value stored in WidgetStateManager.\n  P extends ValueElementProtoInterfaceWithSetValue // Proto for this widget.\n> extends BaseArgs<T, P> {\n  // Important: these callback functions need to have stable references! So\n  // either declare them at the module level or wrap in useCallback.\n  getDefaultStateFromProto: (el: P) => T\n  getCurrStateFromProto: (el: P) => T\n}\n\n/**\n * A React hook that makes the simplest kinds of widgets very easy to implement.\n */\nexport function useBasicWidgetState<\n  T, // Type of the value stored in WidgetStateManager.\n  P extends ValueElementProtoInterfaceWithSetValue // Proto for this widget.\n>({\n  getStateFromWidgetMgr,\n  getDefaultStateFromProto,\n  getCurrStateFromProto,\n  updateWidgetMgrState,\n  element,\n  widgetMgr,\n  fragmentId,\n  onFormCleared,\n}: UseBasicWidgetStateArgs<T, P>): [\n  T,\n  Dispatch<SetStateAction<ValueWithSource<T> | null>>\n] {\n  const getDefaultState = useCallback<(wm: WidgetStateManager, el: P) => T>(\n    (wm, el) => {\n      return getDefaultStateFromProto(el)\n    },\n    [getDefaultStateFromProto]\n  )\n\n  const [currentValue, setNextValueWithSource] = useBasicWidgetClientState({\n    getStateFromWidgetMgr,\n    getDefaultState,\n    updateWidgetMgrState,\n    element,\n    widgetMgr,\n    fragmentId,\n    onFormCleared,\n  })\n\n  // Respond to value changes via session_state. This is also set via an\n  // \"event\", this time using the .setValue property of the proto.\n  useEffect(() => {\n    if (!element.setValue) return\n    element.setValue = false // Clear \"event\".\n\n    setNextValueWithSource({\n      value: getCurrStateFromProto(element),\n      fromUi: false,\n    })\n  }, [element, getCurrStateFromProto, setNextValueWithSource])\n\n  return [currentValue, setNextValueWithSource]\n}\n"],"names":["FormClearHelper","constructor","formClearListener","lastWidgetMgr","lastFormId","manageFormClearListener","widgetMgr","formId","listener","notNullOrUndefined","this","disconnect","isValidFormId","addFormClearedListener","_this$formClearListen","undefined","useFormClearHelper","_ref","element","onFormCleared","useEffect","getStateFromWidgetMgr","getIntValue","getDefaultStateFromProto","_element$default","default","getCurrStateFromProto","_element$value","value","updateWidgetMgrState","valueWithSource","fragmentId","setIntValue","fromUi","Selectbox","disabled","width","options","help","label","labelVisibility","placeholder","setValueWithSource","useBasicWidgetState","onChange","useCallback","clearable","isNullOrUndefined","_jsx","UISelectbox","labelVisibilityProtoValueToEnum","memo","useBasicWidgetClientState","getDefaultState","currentValue","setCurrentValue","useState","_getStateFromWidgetMg","nextValueWithSource","setNextValueWithSource","handleFormCleared","_ref2","wm","el","setValue"],"sourceRoot":""}