{"version":3,"file":"static/js/9074.17324e94.chunk.js","mappings":"oKA2Be,SAASA,EAAKC,GAIC,IAJA,QAC5BC,EAAO,MACPC,EAAK,UACLC,GACWH,EACX,MAAMI,GAAWC,EAAAA,EAAAA,QAAyB,OAEpC,UAAEC,EAAS,QAAEC,EAAO,KAAEC,GAASP,GAGrCQ,EAAAA,EAAAA,YAAU,KACJL,EAASM,UACXN,EAASM,QAAQC,YAAcL,EACjC,GACC,CAACA,KAEJG,EAAAA,EAAAA,YAAU,KACR,MAAMG,EAAYR,EAASM,QAErBG,EAA2BA,KAC3BD,IAEFA,EAAUD,YAAcV,EAAQK,UAClC,EAOF,OAJIM,GACFA,EAAUE,iBAAiB,iBAAkBD,GAGxC,KACDD,GACFA,EAAUG,oBAAoB,iBAAkBF,EAClD,CACD,GACA,CAACZ,KAGJQ,EAAAA,EAAAA,YAAU,KACR,MAAMG,EAAYR,EAASM,QAC3B,IAAKE,EAAW,OAGhB,IAAII,GAAmB,EAEvB,MAAMC,EAAmBA,KACnBV,EAAU,GAAKK,EAAUD,aAAeJ,IACtCC,GAEFI,EAAUD,YAAcL,GAAa,EACrCM,EAAUM,QACAF,IACVA,GAAmB,EACnBJ,EAAUO,SAEd,EAOF,OAJIZ,EAAU,GACZK,EAAUE,iBAAiB,aAAcG,GAGpC,KACDL,GAAaL,EAAU,GACzBK,EAAUG,oBAAoB,aAAcE,EAC9C,CACD,GACA,CAACV,EAASC,EAAMF,KAGnBG,EAAAA,EAAAA,YAAU,KACR,MAAMG,EAAYR,EAASM,QAC3B,IAAKE,EAAW,OAGhB,MAAMQ,EAAiBA,KACjBZ,IACFI,EAAUD,YAAcL,GAAa,EACrCM,EAAUM,OACZ,EAKF,OAFAN,EAAUE,iBAAiB,QAASM,GAE7B,KACDR,GACFA,EAAUG,oBAAoB,QAASK,EACzC,CACD,GACA,CAACZ,EAAMF,IAEV,MAAMe,GAASC,EAAAA,EAAAA,IAAwBrB,EAAQsB,KACzCC,EAAMrB,EAAUsB,cAAcJ,GACpC,OACEK,EAAAA,EAAAA,KAAA,SACE,cAAY,UACZC,GAAG,QACHC,IAAKxB,EACLyB,UAAQ,EACRC,IAAKN,EACLO,UAAU,UACVC,MAAO,CAAE9B,UAGf,C","sources":["../../../streamlit/frontend/lib/src/components/elements/Audio/Audio.tsx"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { ReactElement, useEffect, useRef } from \"react\"\nimport { Audio as AudioProto } from \"@streamlit/lib/src/proto\"\nimport { StreamlitEndpoints } from \"@streamlit/lib/src/StreamlitEndpoints\"\nimport { useStliteMediaObjectUrl } from \"@stlite/kernel\"\n\nexport interface AudioProps {\n  endpoints: StreamlitEndpoints\n  width: number\n  element: AudioProto\n}\n\nexport default function Audio({\n  element,\n  width,\n  endpoints,\n}: AudioProps): ReactElement {\n  const audioRef = useRef<HTMLAudioElement>(null)\n\n  const { startTime, endTime, loop } = element\n\n  // Handle startTime changes\n  useEffect(() => {\n    if (audioRef.current) {\n      audioRef.current.currentTime = startTime\n    }\n  }, [startTime])\n\n  useEffect(() => {\n    const audioNode = audioRef.current\n\n    const setStartTime: () => void = () => {\n      if (audioNode) {\n        // setStartTime\n        audioNode.currentTime = element.startTime\n      }\n    }\n\n    if (audioNode) {\n      audioNode.addEventListener(\"loadedmetadata\", setStartTime)\n    }\n\n    return () => {\n      if (audioNode) {\n        audioNode.removeEventListener(\"loadedmetadata\", setStartTime)\n      }\n    }\n  }, [element])\n\n  // Stop the audio at 'endTime' and handle loop\n  useEffect(() => {\n    const audioNode = audioRef.current\n    if (!audioNode) return\n\n    // Flag to avoid calling 'audioNode.pause()' multiple times\n    let stoppedByEndTime = false\n\n    const handleTimeUpdate = (): void => {\n      if (endTime > 0 && audioNode.currentTime >= endTime) {\n        if (loop) {\n          // If loop is true and we reached 'endTime', reset to 'startTime'\n          audioNode.currentTime = startTime || 0\n          audioNode.play()\n        } else if (!stoppedByEndTime) {\n          stoppedByEndTime = true\n          audioNode.pause()\n        }\n      }\n    }\n\n    if (endTime > 0) {\n      audioNode.addEventListener(\"timeupdate\", handleTimeUpdate)\n    }\n\n    return () => {\n      if (audioNode && endTime > 0) {\n        audioNode.removeEventListener(\"timeupdate\", handleTimeUpdate)\n      }\n    }\n  }, [endTime, loop, startTime])\n\n  // Handle looping the audio\n  useEffect(() => {\n    const audioNode = audioRef.current\n    if (!audioNode) return\n\n    // Loop the audio when it has ended\n    const handleAudioEnd = (): void => {\n      if (loop) {\n        audioNode.currentTime = startTime || 0 // Reset to startTime or to the start if not specified\n        audioNode.play()\n      }\n    }\n\n    audioNode.addEventListener(\"ended\", handleAudioEnd)\n\n    return () => {\n      if (audioNode) {\n        audioNode.removeEventListener(\"ended\", handleAudioEnd)\n      }\n    }\n  }, [loop, startTime])\n\n  const rawUrl = useStliteMediaObjectUrl(element.url)\n  const uri = endpoints.buildMediaURL(rawUrl)\n  return (\n    <audio\n      data-testid=\"stAudio\"\n      id=\"audio\"\n      ref={audioRef}\n      controls\n      src={uri}\n      className=\"stAudio\"\n      style={{ width }}\n    />\n  )\n}\n"],"names":["Audio","_ref","element","width","endpoints","audioRef","useRef","startTime","endTime","loop","useEffect","current","currentTime","audioNode","setStartTime","addEventListener","removeEventListener","stoppedByEndTime","handleTimeUpdate","play","pause","handleAudioEnd","rawUrl","useStliteMediaObjectUrl","url","uri","buildMediaURL","_jsx","id","ref","controls","src","className","style"],"sourceRoot":""}