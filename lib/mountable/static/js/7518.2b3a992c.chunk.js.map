{"version":3,"file":"static/js/7518.2b3a992c.chunk.js","mappings":"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","sources":["../../../streamlit/frontend/src/hocs/withMapboxToken/MapboxToken.ts","../../../streamlit/frontend/src/hocs/withMapboxToken/MapboxTokenError.tsx","../../../streamlit/frontend/src/hocs/withMapboxToken/withMapboxToken.tsx","../../../streamlit/frontend/src/components/elements/DeckGlJsonChart/styled-components.ts","../../../streamlit/frontend/src/components/elements/DeckGlJsonChart/DeckGlJsonChart.tsx"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport axios from \"axios\"\nimport { ensureError } from \"src/lib/ErrorHandling\"\nimport { SessionInfo } from \"src/lib/SessionInfo\"\n\nexport class MapboxTokenNotProvidedError extends Error {}\nexport class MapboxTokenFetchingError extends Error {}\n\n/**\n * A remote file that stores user-visible tokens.\n */\nexport const TOKENS_URL = \"https://data.streamlit.io/tokens.json\"\n\nexport class MapboxToken {\n  static token?: string\n\n  static commandLine?: string\n\n  private static isRunningLocal = (): boolean => {\n    const { hostname } = window.location\n\n    return hostname === \"localhost\" || hostname === \"127.0.0.1\"\n  }\n\n  /**\n   * Expose a singleton MapboxToken:\n   * - If the user specified a token in their streamlit config, return it.\n   * - Else, fetch the remote \"tokens.json\" and return the \"mapbox\" entry.\n   *\n   * (The returned value is cached in memory, so the remote resource will\n   * only be fetched once per session.)\n   */\n  public static async get(): Promise<string> {\n    const { commandLine, userMapboxToken } = SessionInfo.current\n\n    if (\n      !MapboxToken.token ||\n      MapboxToken.commandLine !== commandLine.toLowerCase()\n    ) {\n      if (userMapboxToken !== \"\") {\n        MapboxToken.token = userMapboxToken\n      } else {\n        // TODO: Replace this with the block below after October 1st 2020.\n        MapboxToken.token = await this.fetchToken(TOKENS_URL, \"mapbox\")\n        // if (this.isRunningLocal() && SessionInfo.isHello) {\n        //   MapboxToken.token = await this.fetchToken(TOKENS_URL, \"mapbox-localhost\")\n        // } else {\n        //   throw new MapboxTokenNotProvidedError(\"No Mapbox token provided\")\n        // }\n      }\n\n      MapboxToken.commandLine = commandLine.toLowerCase()\n    }\n\n    return MapboxToken.token\n  }\n\n  private static async fetchToken(\n    url: string,\n    tokenName: string\n  ): Promise<string> {\n    try {\n      const response = await axios.get(url)\n      const { [tokenName]: token } = response.data\n\n      if (token == null || token === \"\") {\n        throw new Error(`Missing token \"${tokenName}\"`)\n      }\n\n      return token\n    } catch (e) {\n      const error = ensureError(e)\n      throw new MapboxTokenFetchingError(`${error.message} (${url})`)\n    }\n  }\n}\n","/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { ReactElement } from \"react\"\nimport ErrorElement from \"src/components/shared/ErrorElement\"\nimport {\n  MapboxTokenFetchingError,\n  MapboxTokenNotProvidedError,\n} from \"src/hocs/withMapboxToken/MapboxToken\"\n\ninterface Props {\n  error: Error | MapboxTokenFetchingError | MapboxTokenNotProvidedError\n  deltaType: string\n  width: number\n}\n\nconst MapboxTokenError = ({\n  error,\n  width,\n  deltaType,\n}: Props): ReactElement => {\n  if (error instanceof MapboxTokenNotProvidedError) {\n    return (\n      <ErrorElement\n        width={width}\n        name=\"No Mapbox token provided\"\n        message={\n          <>\n            <p>\n              To use <code>st.{deltaType}</code> or <code>st.map</code> you\n              need to set up a Mapbox access token.\n            </p>\n\n            <p>\n              To get a token, create an account at{\" \"}\n              <a href=\"https://mapbox.com\">https://mapbox.com</a>. It's free\n              for moderate usage levels!\n            </p>\n\n            <p>\n              Once you have a token, just set it using the Streamlit config\n              option <code>mapbox.token</code> and don't forget to restart your\n              Streamlit server at this point if it's still running, then reload\n              this tab.\n            </p>\n\n            <p>\n              See{\" \"}\n              <a href=\"https://docs.streamlit.io/library/advanced-features/configuration#view-all-configuration-options\">\n                our documentation\n              </a>{\" \"}\n              for more info on how to set config options.\n            </p>\n          </>\n        }\n      />\n    )\n  }\n\n  if (error instanceof MapboxTokenFetchingError) {\n    return (\n      <ErrorElement\n        width={width}\n        name=\"Error fetching Streamlit Mapbox token\"\n        message={\n          <>\n            <p>This app requires an internet connection.</p>\n            <p>Please check your connection and try again.</p>\n            <p>\n              If you think this is a bug, please file bug report{\" \"}\n              <a href=\"https://github.com/streamlit/streamlit/issues/new/choose\">\n                here\n              </a>\n              .\n            </p>\n          </>\n        }\n      />\n    )\n  }\n\n  return (\n    <ErrorElement\n      width={width}\n      name=\"Error fetching Streamlit Mapbox token\"\n      message={error.message}\n    />\n  )\n}\n\nexport default MapboxTokenError\n","/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Alert from \"src/components/elements/Alert\"\nimport { Kind } from \"src/components/shared/AlertContainer\"\nimport { MapboxToken } from \"src/hocs/withMapboxToken/MapboxToken\"\nimport { ensureError } from \"src/lib/ErrorHandling\"\nimport hoistNonReactStatics from \"hoist-non-react-statics\"\nimport React, { ComponentType, PureComponent, ReactNode } from \"react\"\nimport MapboxTokenError from \"./MapboxTokenError\"\n\ninterface Props {\n  width: number\n}\n\ninterface State {\n  mapboxToken?: string\n  mapboxTokenError?: Error\n  isFetching: boolean\n}\n\n/**\n * A higher-order component that fetches our mapbox token and passes\n * it through to the wrapped component. If the token fetch fails, an error\n * will be rendered in place of the wrapped component.\n *\n * @param {string} deltaType In case of an exception we show an error with this\n */\n\nconst withMapboxToken =\n  (deltaType: string) =>\n  (WrappedComponent: ComponentType<any>): ComponentType<any> => {\n    class WithMapboxToken extends PureComponent<Props, State> {\n      public static readonly displayName = `withMapboxToken(${\n        WrappedComponent.displayName || WrappedComponent.name\n      })`\n\n      public constructor(props: Props) {\n        super(props)\n\n        this.state = {\n          isFetching: true,\n          mapboxToken: undefined,\n          mapboxTokenError: undefined,\n        }\n\n        this.initMapboxToken()\n      }\n\n      /**\n       * Fetch our MapboxToken.\n       */\n      private initMapboxToken = async (): Promise<void> => {\n        try {\n          const mapboxToken = await MapboxToken.get()\n\n          this.setState({\n            mapboxToken,\n            isFetching: false,\n          })\n        } catch (e) {\n          const error = ensureError(e)\n\n          this.setState({\n            mapboxTokenError: error,\n            isFetching: false,\n          })\n        }\n      }\n\n      public render(): ReactNode {\n        const { mapboxToken, mapboxTokenError, isFetching } = this.state\n        const { width } = this.props\n\n        // We got an error when fetching our mapbox token: show the error.\n        if (mapboxTokenError) {\n          return (\n            <MapboxTokenError\n              width={width}\n              error={mapboxTokenError}\n              deltaType={deltaType}\n            />\n          )\n        }\n\n        // If our mapboxToken hasn't been retrieved yet, show a loading alert.\n        if (isFetching) {\n          return <Alert body={\"Loading...\"} kind={Kind.INFO} width={width} />\n        }\n\n        // We have the mapbox token. Pass it through to our component.\n        return <WrappedComponent mapboxToken={mapboxToken} {...this.props} />\n      }\n    }\n\n    return hoistNonReactStatics(WithMapboxToken, WrappedComponent)\n  }\n\nexport default withMapboxToken\n","/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport styled from \"@emotion/styled\"\nimport { hasLightBackgroundColor } from \"src/theme\"\n\nexport interface StyledDeckGlChartProps {\n  width: number\n  height: number\n}\n\nexport const StyledDeckGlChart = styled.div<StyledDeckGlChartProps>(\n  ({ width, height, theme }) => ({\n    marginTop: theme.spacing.sm,\n    position: \"relative\",\n    height,\n    width,\n  })\n)\n\nexport const StyledNavigationControlContainer = styled.div(({ theme }) => ({\n  position: \"absolute\",\n  right: \"2.625rem\",\n  top: theme.spacing.md,\n  zIndex: 1,\n\n  // Update zoom buttons based on the active theme\n  \"button:not(:disabled)\": {\n    background: theme.colors.bgColor,\n\n    // Add a separator between buttons\n    \"& + button\": {\n      borderTopColor: theme.colors.secondaryBg,\n    },\n\n    // On dark backgrounds, invert the color for the + and - symbols\n    \"& span\": {\n      filter: hasLightBackgroundColor(theme) ? \"\" : \"invert(100%)\",\n    },\n  },\n}))\n","/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { PureComponent, ReactNode } from \"react\"\nimport { DeckGL } from \"deck.gl\"\nimport isEqual from \"lodash/isEqual\"\nimport { MapContext, StaticMap, NavigationControl } from \"react-map-gl\"\nimport { withTheme } from \"@emotion/react\"\nimport { hasLightBackgroundColor, Theme } from \"src/theme\"\n// We don't have Typescript defs for these imports, which makes ESLint unhappy\n/* eslint-disable import/no-extraneous-dependencies */\nimport * as layers from \"@deck.gl/layers\"\nimport { JSONConverter } from \"@deck.gl/json\"\nimport * as geoLayers from \"@deck.gl/geo-layers\"\nimport * as aggregationLayers from \"@deck.gl/aggregation-layers\"\nimport * as meshLayers from \"@deck.gl/mesh-layers\"\n/* eslint-enable */\n\nimport { CSVLoader } from \"@loaders.gl/csv\"\nimport { GLTFLoader } from \"@loaders.gl/gltf\"\nimport { registerLoaders } from \"@loaders.gl/core\"\n\nimport withFullScreenWrapper from \"src/hocs/withFullScreenWrapper\"\nimport withMapboxToken from \"src/hocs/withMapboxToken\"\n\nimport { notNullOrUndefined } from \"src/lib/utils\"\n\nimport { DeckGlJsonChart as DeckGlJsonChartProto } from \"src/autogen/proto\"\nimport {\n  StyledDeckGlChart,\n  StyledNavigationControlContainer,\n} from \"./styled-components\"\n\nimport \"mapbox-gl/dist/mapbox-gl.css\"\n\ninterface PickingInfo {\n  object: {\n    [key: string]: string\n  }\n}\n\ninterface DeckObject {\n  initialViewState: {\n    height: number\n    width: number\n  }\n  layers: Record<string, unknown>[]\n  mapStyle?: string | Array<string>\n}\n\nconst configuration = {\n  classes: { ...layers, ...aggregationLayers, ...geoLayers, ...meshLayers },\n}\n\nregisterLoaders([CSVLoader, GLTFLoader])\n\nconst jsonConverter = new JSONConverter({ configuration })\n\ninterface Props {\n  width: number\n  theme: Theme\n  mapboxToken: string\n  element: DeckGlJsonChartProto\n}\n\nexport interface PropsWithHeight extends Props {\n  height: number | undefined\n}\n\ninterface State {\n  viewState: Record<string, unknown>\n  initialized: boolean\n  initialViewState: Record<string, unknown>\n}\n\nexport const DEFAULT_DECK_GL_HEIGHT = 500\n\nexport class DeckGlJsonChart extends PureComponent<PropsWithHeight, State> {\n  readonly state = {\n    viewState: {\n      bearing: 0,\n      pitch: 0,\n      zoom: 11,\n    },\n    initialized: false,\n    initialViewState: {},\n  }\n\n  componentDidMount = (): void => {\n    // HACK: Load layers a little after loading the map, to hack around a bug\n    // where HexagonLayers were not drawing on first load but did load when the\n    // script got re-executed.\n    this.setState({\n      initialized: true,\n    })\n  }\n\n  static getDerivedStateFromProps(\n    props: Readonly<PropsWithHeight>,\n    state: Partial<State>\n  ): Partial<State> | null {\n    const deck = DeckGlJsonChart.getDeckObject(props)\n\n    // If the ViewState on the server has changed, apply the diff to the current state\n    if (!isEqual(deck.initialViewState, state.initialViewState)) {\n      const diff = Object.keys(deck.initialViewState).reduce(\n        (diff, key): any => {\n          // @ts-ignore\n          if (deck.initialViewState[key] === state.initialViewState[key]) {\n            return diff\n          }\n\n          return {\n            ...diff,\n            // @ts-ignore\n            [key]: deck.initialViewState[key],\n          }\n        },\n        {}\n      )\n\n      return {\n        viewState: { ...state.viewState, ...diff },\n        initialViewState: deck.initialViewState,\n      }\n    }\n\n    return null\n  }\n\n  static getDeckObject = (props: PropsWithHeight): DeckObject => {\n    const { element, width, height, theme } = props\n    const json = JSON.parse(element.json)\n\n    // If unset, use either the Mapbox light or dark style based on Streamlit's theme\n    // For Mapbox styles, see https://docs.mapbox.com/api/maps/styles/#mapbox-styles\n    if (!notNullOrUndefined(json.mapStyle)) {\n      const mapTheme = hasLightBackgroundColor(theme) ? \"light\" : \"dark\"\n      json.mapStyle = `mapbox://styles/mapbox/${mapTheme}-v9`\n    }\n\n    // The graph dimensions could be set from props ( like withFullscreen ) or\n    // from the generated element object\n    if (height) {\n      json.initialViewState.height = height\n      json.initialViewState.width = width\n    } else {\n      if (!json.initialViewState.height) {\n        json.initialViewState.height = DEFAULT_DECK_GL_HEIGHT\n      }\n\n      if (element.useContainerWidth) {\n        json.initialViewState.width = width\n      }\n    }\n\n    delete json.views // We are not using views. This avoids a console warning.\n\n    return jsonConverter.convert(json)\n  }\n\n  createTooltip = (info: PickingInfo): Record<string, unknown> | boolean => {\n    const { element } = this.props\n\n    if (!info || !info.object || !element.tooltip) {\n      return false\n    }\n\n    const tooltip = JSON.parse(element.tooltip)\n\n    // NB: https://deckgl.readthedocs.io/en/latest/tooltip.html\n    if (tooltip.html) {\n      tooltip.html = this.interpolate(info, tooltip.html)\n    } else {\n      tooltip.text = this.interpolate(info, tooltip.text)\n    }\n\n    return tooltip\n  }\n\n  interpolate = (info: PickingInfo, body: string): string => {\n    const matchedVariables = body.match(/{(.*?)}/g)\n    if (matchedVariables) {\n      matchedVariables.forEach((match: string) => {\n        const variable = match.substring(1, match.length - 1)\n\n        if (info.object.hasOwnProperty(variable)) {\n          body = body.replace(match, info.object[variable])\n        }\n      })\n    }\n    return body\n  }\n\n  onViewStateChange = ({ viewState }: State): void => {\n    this.setState({ viewState })\n  }\n\n  render(): ReactNode {\n    const deck = DeckGlJsonChart.getDeckObject(this.props)\n    const { viewState } = this.state\n\n    return (\n      <StyledDeckGlChart\n        className=\"stDeckGlJsonChart\"\n        width={deck.initialViewState.width}\n        height={deck.initialViewState.height}\n      >\n        <DeckGL\n          viewState={viewState}\n          onViewStateChange={this.onViewStateChange}\n          height={deck.initialViewState.height}\n          width={deck.initialViewState.width}\n          layers={this.state.initialized ? deck.layers : []}\n          getTooltip={this.createTooltip}\n          ContextProvider={MapContext.Provider}\n          controller\n        >\n          <StaticMap\n            height={deck.initialViewState.height}\n            width={deck.initialViewState.width}\n            mapStyle={\n              deck.mapStyle &&\n              (typeof deck.mapStyle === \"string\"\n                ? deck.mapStyle\n                : deck.mapStyle[0])\n            }\n            mapboxApiAccessToken={this.props.mapboxToken}\n          />\n          <StyledNavigationControlContainer>\n            <NavigationControl className=\"zoomButton\" showCompass={false} />\n          </StyledNavigationControlContainer>\n        </DeckGL>\n      </StyledDeckGlChart>\n    )\n  }\n}\n\nexport default withTheme(\n  withMapboxToken(\"st.pydeck_chart\")(withFullScreenWrapper(DeckGlJsonChart))\n)\n"],"names":["MapboxTokenNotProvidedError","Error","MapboxTokenFetchingError","MapboxToken","SessionInfo","commandLine","userMapboxToken","token","toLowerCase","this","fetchToken","url","tokenName","axios","response","data","error","ensureError","message","isRunningLocal","hostname","window","location","width","deltaType","ErrorElement","name","href","WrappedComponent","WithMapboxToken","props","initMapboxToken","get","mapboxToken","setState","isFetching","mapboxTokenError","state","undefined","Alert","body","kind","Kind","PureComponent","displayName","hoistNonReactStatics","StyledDeckGlChart","height","marginTop","theme","spacing","sm","position","StyledNavigationControlContainer","right","top","md","zIndex","background","colors","bgColor","borderTopColor","secondaryBg","filter","hasLightBackgroundColor","configuration","classes","layers","aggregationLayers","geoLayers","meshLayers","registerLoaders","CSVLoader","GLTFLoader","jsonConverter","JSONConverter","DeckGlJsonChart","viewState","bearing","pitch","zoom","initialized","initialViewState","componentDidMount","createTooltip","info","element","object","tooltip","JSON","parse","html","interpolate","text","matchedVariables","match","forEach","variable","substring","length","hasOwnProperty","replace","onViewStateChange","deck","getDeckObject","className","getTooltip","ContextProvider","MapContext","controller","mapStyle","mapboxApiAccessToken","showCompass","isEqual","diff","Object","keys","reduce","key","json","notNullOrUndefined","mapTheme","useContainerWidth","views","convert","withTheme","withMapboxToken","withFullScreenWrapper"],"sourceRoot":""}