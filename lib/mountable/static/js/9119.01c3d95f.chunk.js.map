{"version":3,"file":"static/js/9119.01c3d95f.chunk.js","mappings":"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","sources":["../../../streamlit/frontend/lib/src/components/widgets/ColorPicker/ColorPicker.tsx","../../../streamlit/frontend/lib/src/components/widgets/Form/FormClearHelper.ts","../../../streamlit/frontend/lib/src/useBasicWidgetState.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { FC, memo, useCallback } from \"react\"\n\nimport { ColorPicker as ColorPickerProto } from \"@streamlit/lib/src/proto\"\nimport { WidgetStateManager } from \"@streamlit/lib/src/WidgetStateManager\"\nimport BaseColorPicker from \"@streamlit/lib/src/components/shared/BaseColorPicker\"\nimport { labelVisibilityProtoValueToEnum } from \"@streamlit/lib/src/util/utils\"\nimport {\n  useBasicWidgetState,\n  ValueWithSource,\n} from \"@streamlit/lib/src/useBasicWidgetState\"\n\nexport interface Props {\n  disabled: boolean\n  element: ColorPickerProto\n  widgetMgr: WidgetStateManager\n  width: number\n  fragmentId?: string\n}\n\n/**\n * The value specified by the user via the UI. If the user didn't touch this\n * widget's UI, the default value is used.\n */\ntype ColorPickerValue = string\n\nconst getStateFromWidgetMgr = (\n  widgetMgr: WidgetStateManager,\n  element: ColorPickerProto\n): ColorPickerValue | undefined => {\n  return widgetMgr.getStringValue(element)\n}\n\nconst getDefaultStateFromProto = (\n  element: ColorPickerProto\n): ColorPickerValue => {\n  return element.default ?? null\n}\n\nconst getCurrStateFromProto = (\n  element: ColorPickerProto\n): ColorPickerValue => {\n  return element.value ?? null\n}\n\nconst updateWidgetMgrState = (\n  element: ColorPickerProto,\n  widgetMgr: WidgetStateManager,\n  valueWithSource: ValueWithSource<ColorPickerValue>,\n  fragmentId?: string\n): void => {\n  widgetMgr.setStringValue(\n    element,\n    valueWithSource.value,\n    { fromUi: valueWithSource.fromUi },\n    fragmentId\n  )\n}\n\nconst ColorPicker: FC<Props> = ({\n  element,\n  disabled,\n  widgetMgr,\n  width,\n  fragmentId,\n}) => {\n  const [value, setValueWithSource] = useBasicWidgetState<\n    ColorPickerValue,\n    ColorPickerProto\n  >({\n    getStateFromWidgetMgr,\n    getDefaultStateFromProto,\n    getCurrStateFromProto,\n    updateWidgetMgrState,\n    element,\n    widgetMgr,\n    fragmentId,\n  })\n\n  const handleColorClose = useCallback(\n    (color: string): void => {\n      setValueWithSource({ value: color, fromUi: true })\n    },\n    [setValueWithSource]\n  )\n\n  return (\n    <BaseColorPicker\n      label={element.label}\n      labelVisibility={labelVisibilityProtoValueToEnum(\n        element.labelVisibility?.value\n      )}\n      help={element.help}\n      onChange={handleColorClose}\n      disabled={disabled}\n      width={width}\n      value={value}\n    />\n  )\n}\n\nexport default memo(ColorPicker)\n","/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { useEffect } from \"react\"\n\nimport { SignalConnection } from \"typed-signals\"\n\nimport {\n  isValidFormId,\n  notNullOrUndefined,\n} from \"@streamlit/lib/src/util/utils\"\nimport { WidgetStateManager } from \"@streamlit/lib/src/WidgetStateManager\"\n\nexport class FormClearHelper {\n  private formClearListener?: SignalConnection\n\n  private lastWidgetMgr?: WidgetStateManager\n\n  private lastFormId?: string\n\n  /**\n   * Register the listener that will be called when the widget's form is cleared.\n   * This should be called in the `render` function of every class-based widget\n   * element - it mimics the behavior of a `useEffect` hook, and ensures that\n   * subscription and unsubscription happen correctly.\n   *\n   * Hooks-based widgets can just use `useEffect` and call\n   * `widgetMgr.addFormClearedListener` directly. Or just use the convenient\n   * hook `useFormClearHelper`, below.\n   */\n  public manageFormClearListener(\n    widgetMgr: WidgetStateManager,\n    formId: string,\n    listener: () => void\n  ): void {\n    // If we're already subscribed and our params haven't changed, early-out.\n    if (\n      notNullOrUndefined(this.formClearListener) &&\n      this.lastWidgetMgr === widgetMgr &&\n      this.lastFormId === formId\n    ) {\n      return\n    }\n\n    // Close our previous subscription, if we had one.\n    this.disconnect()\n\n    // If we're not part of a form, there's nothing to do.\n    if (!isValidFormId(formId)) {\n      return\n    }\n\n    // Make the new subscription.\n    this.formClearListener = widgetMgr.addFormClearedListener(formId, listener)\n    this.lastWidgetMgr = widgetMgr\n    this.lastFormId = formId\n  }\n\n  /**\n   * Disconnect from the form-clear signal, if we're connected.\n   * This should be called from the `componentWillUnmount` function of every\n   * element that uses it.\n   */\n  public disconnect(): void {\n    this.formClearListener?.disconnect()\n    this.formClearListener = undefined\n    this.lastWidgetMgr = undefined\n    this.lastFormId = undefined\n  }\n}\n\ninterface FormElementProtoInterface {\n  formId: string\n}\n\ninterface FormClearHelperArgs {\n  element: FormElementProtoInterface\n  widgetMgr: WidgetStateManager\n  onFormCleared: () => void\n}\n\nexport function useFormClearHelper({\n  element,\n  widgetMgr,\n  onFormCleared,\n}: FormClearHelperArgs): void {\n  useEffect(() => {\n    if (!isValidFormId(element.formId)) {\n      return\n    }\n\n    const formClearListener = widgetMgr.addFormClearedListener(\n      element.formId,\n      onFormCleared\n    )\n\n    return () => {\n      formClearListener.disconnect()\n    }\n  }, [element, widgetMgr, onFormCleared])\n}\n","/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Dispatch,\n  SetStateAction,\n  useCallback,\n  useEffect,\n  useState,\n} from \"react\"\n\nimport {\n  Source,\n  WidgetStateManager,\n} from \"@streamlit/lib/src/WidgetStateManager\"\nimport { useFormClearHelper } from \"@streamlit/lib/src/components/widgets/Form\"\nimport { isNullOrUndefined } from \"@streamlit/lib/src/util/utils\"\n\nexport type ValueWithSource<T> = {\n  value: T\n} & Source\n\n// Interface for a proto that has a .formId\ninterface ValueElementProtoInterface {\n  formId: string\n}\n\ninterface BaseArgs<\n  T, // Type of the value stored in WidgetStateManager.\n  P extends ValueElementProtoInterface // Proto for this widget.\n> {\n  // Important: these callback functions need to have stable references! So\n  // either declare them at the module level or wrap in useCallback.\n  getStateFromWidgetMgr: (wm: WidgetStateManager, el: P) => T | undefined\n  updateWidgetMgrState: (\n    el: P,\n    wm: WidgetStateManager,\n    vws: ValueWithSource<T>,\n    fragmentId?: string\n  ) => void\n  element: P\n  widgetMgr: WidgetStateManager\n  fragmentId?: string\n  onFormCleared?: () => void\n}\n\nexport interface UseBasicWidgetClientStateArgs<\n  T, // Type of the value stored in WidgetStateManager.\n  P extends ValueElementProtoInterface // Proto for this widget.\n> extends BaseArgs<T, P> {\n  // Important: these callback functions need to have stable references! So\n  // either declare them at the module level or wrap in useCallback.\n  getDefaultState: (wm: WidgetStateManager, el: P) => T\n}\n\n/**\n * A React hook that makes the simplest kinds of widgets very easy to implement.\n * Use the clientState version when the widget does not have a .setValue on its\n * proto, otherwise utilize `useBasicWidgetState`.\n */\nexport function useBasicWidgetClientState<\n  T, // Type of the value stored in WidgetStateManager.\n  P extends ValueElementProtoInterface // Proto for this widget.\n>({\n  getStateFromWidgetMgr,\n  getDefaultState,\n  updateWidgetMgrState,\n  element,\n  widgetMgr,\n  fragmentId,\n  onFormCleared,\n}: UseBasicWidgetClientStateArgs<T, P>): [\n  T,\n  Dispatch<SetStateAction<ValueWithSource<T> | null>>\n] {\n  const [currentValue, setCurrentValue] = useState<T>(() => {\n    // If WidgetStateManager knew a value for this widget, initialize to that.\n    // Otherwise, use the default value.\n    return (\n      getStateFromWidgetMgr(widgetMgr, element) ??\n      getDefaultState(widgetMgr, element)\n    )\n  })\n\n  // This acts as an \"event\":\n  // - It's null most of the time\n  // - It only has a value the moment when the user calls setValue (internally\n  //   called setNextValueWithSource). And then it's immediately set to null\n  //   internally.\n  const [nextValueWithSource, setNextValueWithSource] =\n    useState<ValueWithSource<T> | null>({\n      value: currentValue,\n      fromUi: false,\n    })\n\n  // When someone calls setNextValueWithSource, update internal state and tell\n  // widget manager to update its state too.\n  useEffect(() => {\n    if (isNullOrUndefined(nextValueWithSource)) return\n    setNextValueWithSource(null) // Clear \"event\".\n\n    setCurrentValue(nextValueWithSource.value)\n    updateWidgetMgrState(element, widgetMgr, nextValueWithSource, fragmentId)\n  }, [\n    nextValueWithSource,\n    updateWidgetMgrState,\n    element,\n    widgetMgr,\n    fragmentId,\n  ])\n\n  /**\n   * If we're part of a clear_on_submit form, this will be called when our\n   * form is submitted. Restore our default value and update the WidgetManager.\n   */\n  const handleFormCleared = useCallback((): void => {\n    setNextValueWithSource({\n      value: getDefaultState(widgetMgr, element),\n      fromUi: true,\n    })\n    onFormCleared?.()\n  }, [\n    setNextValueWithSource,\n    element,\n    getDefaultState,\n    widgetMgr,\n    onFormCleared,\n  ])\n\n  // Manage our form-clear event handler.\n  useFormClearHelper({ widgetMgr, element, onFormCleared: handleFormCleared })\n\n  return [currentValue, setNextValueWithSource]\n}\n\n// Interface for a proto that has a setValue, and .formId\ninterface ValueElementProtoInterfaceWithSetValue\n  extends ValueElementProtoInterface {\n  setValue: boolean\n}\n\nexport interface UseBasicWidgetStateArgs<\n  T, // Type of the value stored in WidgetStateManager.\n  P extends ValueElementProtoInterfaceWithSetValue // Proto for this widget.\n> extends BaseArgs<T, P> {\n  // Important: these callback functions need to have stable references! So\n  // either declare them at the module level or wrap in useCallback.\n  getDefaultStateFromProto: (el: P) => T\n  getCurrStateFromProto: (el: P) => T\n}\n\n/**\n * A React hook that makes the simplest kinds of widgets very easy to implement.\n */\nexport function useBasicWidgetState<\n  T, // Type of the value stored in WidgetStateManager.\n  P extends ValueElementProtoInterfaceWithSetValue // Proto for this widget.\n>({\n  getStateFromWidgetMgr,\n  getDefaultStateFromProto,\n  getCurrStateFromProto,\n  updateWidgetMgrState,\n  element,\n  widgetMgr,\n  fragmentId,\n  onFormCleared,\n}: UseBasicWidgetStateArgs<T, P>): [\n  T,\n  Dispatch<SetStateAction<ValueWithSource<T> | null>>\n] {\n  const getDefaultState = useCallback<(wm: WidgetStateManager, el: P) => T>(\n    (wm, el) => {\n      return getDefaultStateFromProto(el)\n    },\n    [getDefaultStateFromProto]\n  )\n\n  const [currentValue, setNextValueWithSource] = useBasicWidgetClientState({\n    getStateFromWidgetMgr,\n    getDefaultState,\n    updateWidgetMgrState,\n    element,\n    widgetMgr,\n    fragmentId,\n    onFormCleared,\n  })\n\n  // Respond to value changes via session_state. This is also set via an\n  // \"event\", this time using the .setValue property of the proto.\n  useEffect(() => {\n    if (!element.setValue) return\n    element.setValue = false // Clear \"event\".\n\n    setNextValueWithSource({\n      value: getCurrStateFromProto(element),\n      fromUi: false,\n    })\n  }, [element, getCurrStateFromProto, setNextValueWithSource])\n\n  return [currentValue, setNextValueWithSource]\n}\n"],"names":["getStateFromWidgetMgr","widgetMgr","element","getStringValue","getDefaultStateFromProto","_element$default","default","getCurrStateFromProto","_element$value","value","updateWidgetMgrState","valueWithSource","fragmentId","setStringValue","fromUi","ColorPicker","_ref","_element$labelVisibil","disabled","width","setValueWithSource","useBasicWidgetState","handleColorClose","useCallback","color","_jsx","BaseColorPicker","label","labelVisibility","labelVisibilityProtoValueToEnum","help","onChange","memo","FormClearHelper","constructor","formClearListener","lastWidgetMgr","lastFormId","manageFormClearListener","formId","listener","notNullOrUndefined","this","disconnect","isValidFormId","addFormClearedListener","_this$formClearListen","undefined","useFormClearHelper","onFormCleared","useEffect","useBasicWidgetClientState","getDefaultState","currentValue","setCurrentValue","useState","_getStateFromWidgetMg","nextValueWithSource","setNextValueWithSource","isNullOrUndefined","handleFormCleared","_ref2","wm","el","setValue"],"sourceRoot":""}